Types of Programming
--------------------
- In programming, there are different paradigms or patterns that define how to write and structure our code. Alos, each paradigm has different functionalities and behaviours.
- There are various types of programming patterns such as,
1. Structural programming
2. Procedural programming
3. Object-oriented programming
4. Functional programming
And more

- Structural programming structures the code representing the data with some basic functionalities
- Procedural programming uses functions as building blocks
- Object-oriented programming is programming paradigm that provides a means for structuring programs so that properties and behaviours are bundled into individual objects

Object Oriented Programming concept (OOPS)
------------------------------------------
- OOPs in python is a programming approach that focuses on using objects and classes as the building blocks of the program.
- It allows developers to develop applications using the OOPs approach with major focus on code reusability.
- OOPs is an approach for modeling concrete, real-world things, and relations between those things.
- OOPs model real-world entities as programming objects that have some data associated with them and can perform certain functions.

Principles of OOP
-----------------
- Following are the four main principles/pillars/properties of OOP
1. Abstraction
2. Encapsulation
3. Inheritance
4. Polymorphism

Abstraction:
-----------
- means to abstract only the details/data which might concern the user
- As an example, when we use a mobile phone, we just think about how the touch works, how the fingerprint scanner, home button, camera, etc work. We wont worry about how those things are implemented internally. Those details about the implementation part are hidden from you as a user and you might not worry about it as well. Abstraction is used to hide complex details and show only the necessary parts.
- Abstraction is abstracting the details that may concern you, which means abstraction involves focusing on the essential elements and ignoring the details that are not important or relevant to you. 

Encapsulation:
--------------
- In encapsulation, we try to encapsulate all the data as a single entity.
- Encapsulation is binding together the data under a single unit
- It refers to the concept of bundling the data (variables) and methods (functions) that operate on the data into a single unit, called a class. Encapsulation helps protect the integrity of the data by restricting direct access to it and allowing controlled access through methods.
- In encapsulation, the internal state of an object is hidden from the outside world. This is usually achieved by marking the variables of a class as private or protected, and providing public methods (getters and setters) to access or modify them. This approach ensures that the object's data is manipulated only through these controlled methods, thus reducing the risk of unauthorized or unintended changes.
- Encapsulation is just like a real-life capsule that your doctor might give you. Inside the capsule, there are various chemical elements mixed to create a single consumable entity. Now, assume that the doctor gives you all those chemical elements and asks you to mix them and take the dosage.Does that make any sense? Ofcourse not! As the consumer, it's not your job to do that.
- Encapsulation also leads to data abstraction or hiding.
- It's just like a black box, wherefrom the one end we can pass input, it processes it and givesthe result as an output from the other end. So what happens in the blackbox is completely hidden.

Example program for encapsulation:
----------------------------------
class Car:
    def __init__(self, brand, model, year):
        self.__brand = brand      # private variable
        self.__model = model      # private variable
        self.__year = year        # private variable

    # Getter method for brand
    def get_brand(self):
        return self.__brand

    # Setter method for brand
    def set_brand(self, brand):
        self.__brand = brand

    # Getter method for model
    def get_model(self):
        return self.__model

    # Setter method for model
    def set_model(self, model):
        self.__model = model

    # Getter method for year
    def get_year(self):
        return self.__year

    # Setter method for year
    def set_year(self, year):
        self.__year = year

# Creating an object of the Car class
my_car = Car("Toyota", "Corolla", 2021)

# Accessing and modifying data using getter and setter methods
print(my_car.get_brand())  # Output: Toyota
my_car.set_year(2023)
print(my_car.get_year())   # Output: 2023

Key Points:
-----------
Private Variables:  
------------------
- In the example, __brand, __model, and __year are private variables, meaning they can't be accessed directly from outside
the class.

Getter and Setter Methods: 
--------------------------
These are used to control how the private variables are accessed and modified.

- Encapsulation helps in maintaining the integrity of the object and prevents unauthorized access or changes to the data.

Inheritance:
------------
- We inherit a lot of things from our parents. Some properties like looks, skin colour, hair, body and not just properties but also behaviours.
We may inherit all the money, wealth, and fortune
- Similarly in programming, one element can inherit  various characteristics and capabilities from another element.(Here the element we are refering to is a 'class').
- It is one of the most important features of OOPs and supports the concept of "reusability". It simply means, when we want to create some feature and there is already such a feature that includes some of the code that we want, then we can derive our feature from the existing one instead of developing from scratch.

Polymorphism:
-------------
- the word polymorphism means having many forms
- ability of something to have more than one form.
- Consider a geometric shape. As a whole, it's termed as a shape, but that shape can have many forms such as triangle, circle, square, rectangle, oval and more.
- Similarly, in programming, an operation may exhibit different behaviours in different instances. The behaviour depends upon the types of data used in the operation.

Classes and objects
------------------
- building blocks of  OOP
- Just like lists,tuples and dictionaries, classes are some advanced data structures to store, manipulate and structure the data
- Tuples, dictionaries, lists store only few attributes but class can store various attributes
- class is a type of user-defined structure that can store various attributes.
- (Data - both primitive and user-defined) along with their functionalities, all together as a single unit.
- These attributes and their functionalities(behaviours) can be accessed via objects.

What is a class?
----------------
- blueprint to create objects
- user-defined prototype for an object that defines the set of attributes that characterize any object of the class.
-  As an example class is analogous to building blueprint, depending upon which we create various real world building structures whose base plan is same, where else the elevations raised from it can be of different attributes like different colors, doors, windows and other interiors.

Objects:
--------
- instance of the class
- As an example, when class is the blueprint, then different buildings raised from it are different objects 
- Object has two things,
    1. Attributes (Data variables of the class)
    2. Behaviours or Methods (Functions defined in the class)
- As an example, if building is the object, then color,floors,flats,entrance etc would be the attributes and isReady(), isOccupied(), flatAvailable() etc would be its behaviours that are methods.
- Each building would have all these data and behaviours different and unique to themselves.

Defining a class:
-----------------
Syntax:
-------
class className:
#body of the class

- 'class' is the keyword used to define the class in python
- className is the namne given to the class. Just like the name of the variable or a function, the name of the class has to be meaningful
- Finally, it is terminated with semicolon
- Inside the class, we can define the attributes and the functions and the body of the class which should be indented.

eg. class Employee:
        pass

- In above example, 'pass' keyword is just like a temporary placeholder until we add the required functionalities.
- The pass statement is simply ignored by the python interpreter and can be seen as a null statement.

eg. class Employee:
        empName = "John"
        age = 35
        designation = "Manager"

- In above example, it won't return any output since a class is just the description
- To access the attributes of the class, we would need to create an object.

Declaring an object
-------------------
syntax:
-------
objName = className()
objName.attributeName
objName.methodName()

- When we declare an object of the class, at that time the memory is allocated to it and then we can access the attribures and methods of the class

eg. class Employee:
    name = "john"
    age = 35
    designation = "Manager"

    emp1 = Employee()
    emp2 = Employee()
    print(emp1.name)
    print(emp1.age)
    print(emp1.designation)
    print(emp2.name)
    print(emp2.age)
    print(emp2.designation)

- In above program we get same output from two different objects. Because our code is rigid and not dynamic. Values are already assigned instead of passed as an argument. 
- But each object is the unique instance of the class and each object has its own attributes and behaviours.
- To get rid of this problem and to create unique objects we go for constructors. 

 Constructors:
 -------------
 - To create a unique object we use constructors, which is used for instantiating an object.
 - The task of the constructor is to initialize the data members of the class when an object is created.

 Syntax:
 ------
 def __init__(self):
    #body of the constructor

- The attributes that all objects must have, are defined in a method called __init__()
- Everytime a new object is created, __init__() sets the initial state of the object by assigning the values of the object's properties
- That is, __init__() initializes each new instance of the class.

Types of constructors
---------------------
1. Default constructor:
-----------------------
    The default constructor is the constructor that doesn't accept any arguments. Its definition has only one argument(self- we wil discuss this later) which is a reference to the instance being constructed.

2. Parameterized constructor:
-----------------------------
    The parameterized constructor takes its first argument as a reference to the instance being constructed known as self and the rest of the arguments are provided. These are the required attributes for the class.

Note:
-----
- When our class has a default constructor, then we can use the syntax , objName = className()

eg. class Employee_1:
    def __init__(self):
        self.name = "John"
        self.age = 35
        self.designation = "Manager"

    emp1 = Employee_1()
    print(emp1.name,emp1.age,emp1.designation)

- If we donot assign any constructor to our class, python automatically assigns the default constructor to the class
- If our class has a parameterized constructor, then we use the syntax, objName = className(parameter1,parameter2,.....parameterN)

eg. class Employee_2:
    def __init__(self,name,age,designation):
        self.name = name
        self.age = age
        self.designation = designation

    emp_1 = Employee_2('Hari',45,'Sr.Manager')
    emp_2 = Employee_2('Vinoth',30,'Manager')
    print(emp_1.name,emp_1.age,emp_1.designation)
    print(emp_2.name,emp_2.age,emp_2.designation)

- 'self' keyword helps the class to understand which current object is accessing the attributes and methods and accordingly return the output.
- 'self' keyword used to represent the current instance of the class

Adding Behaviours and methods:
------------------------------
- Functions defined inside the classes are called methods
- Variables assigned inside the classes are called attributes or behaviours

class variable and instance variable:
-------------------------------------
eg. class Employee:
    totalEmployees = 0

    def __init__(self,name,age,designation,salary):
        self.name = name
        self.age = age
        self.designation = designation
        self.salary = salary
        Employee.totalEmployees += 1

- Here we can see, totalEmployees is not defined inside the __init__method, and also it is not passed inside the constructor.
- This is because that value has to be calculated by the program and should not be passsed at the time of object creation
- Whenever a new object (that is a new employee) is created, we need to update that value by one.
- As we know whenever a new object is created, the __init__method is called. Therefore we update the value by 1 in the __init__method.
- Since this attribute does not depend on the object, we cannot use 'self' to refer to it. Therefore, we directly use the name and access it Employee.totalEmployees
- Such variables that are shared by all the instances(objects) are called Class variables. And the variables that are defined inside __init__ are called Instance variables.

Adding methods:
--------------
eg. def getEmployeeDetails(self):
        return self.name,self.age,self.designation,self.salary
    
    def updateSalary(self,newSalary):
        self.salary = newSalary
        print("Salary updated")
        return self.salary

- The getEmployeeDetails() simply returns all the details about the employee
- The updateSalary() method accepts a parameter as newSalary and updates the self.salary to the passed value.

Total code:
----------

class Employee:
    totalEmployees = 0

    def __init__(self,name,age,designation,salary):
        self.name = name
        self.age = age
        self.designation = designation
        self.salary = salary
        Employee.totalEmployees += 1

    def getEmployeeDetails(self):
        return self.name,self.age,self.designation,self.salary
    
    def updateSalary(self,newSalary):
        self.salary = newSalary
        print("Salary updated")
        return self.salary
    
empOne = Employee('Srinivasan',28,'Jr.developer',25000)
print(empOne.getEmployeeDetails())
empTwo = Employee('Nagulan',38,'Manager',40000)
print(empTwo.getEmployeeDetails())
empOne.updateSalary(30000)
print(empOne.getEmployeeDetails())
print(Employee.totalEmployees)